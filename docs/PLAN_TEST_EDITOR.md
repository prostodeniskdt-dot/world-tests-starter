# План внедрения полноценного редактора тестов

Документ для **агента**: пошаговый план доработки редактора тестов на сайте так, чтобы администратор мог вручную создавать и настраивать тесты без зависимости от импорта JSON.

---

## 1. Текущее состояние (что уже есть)

- **Список тестов** (`/admin/tests`): список тестов, кнопка «Импорт JSON», ссылки «Превью», «Редактировать», публикация, удаление. **Нет** кнопки «Создать пустой тест».
- **Импорт** (`/admin/tests/import`): вставка JSON → валидация → создание теста → редирект на превью. Единственный способ появления теста в БД — импорт.
- **Редактирование** (`/admin/tests/[testId]/edit`):
  - Метаданные: название, описание, категория, сложность, базовые очки, макс. попыток.
  - Вопросы: коллапсируемые карточки; у каждого — ID, текст, подсказка; для `multiple-choice` / `multiple-select` — варианты текстом; **правильный ответ вводится только как сырой JSON**.
  - Для остальных типов (`matching`, `ordering`, `cloze-dropdown`, `true-false-enhanced` и т.д.) — только «Просмотр полного JSON вопроса» и поле «Правильный ответ (JSON)». **Нет** смены типа вопроса, **нет** добавления вопроса, **нет** пошаговых полей под каждый тип.
- **API**: `GET/PUT/DELETE /api/admin/tests/[testId]`, `POST /api/admin/tests` (используется импортом; требует `title`, непустой `questions`, `answerKey` с ответом на каждый вопрос).
- **Типы вопросов** заданы в `src/tests/types.ts`; проверка ответов — в `src/lib/answer-checkers.ts`. Список типов для импорта — в `src/app/admin/tests/import/page.tsx` (validTypes).

**Итог:** ручная настройка возможна только при умении править JSON; для большинства типов вопросов нет удобного пошагового редактирования и нет создания теста «с нуля».

---

## 2. Цели внедрения

1. Создавать тест **без импорта** (пустой тест или с одним вопросом-заглушкой).
2. **Добавлять** и **удалять** вопросы в редакторе.
3. **Менять тип** вопроса с приведением структуры и ключа ответа к выбранному типу.
4. Редактировать **все поля по типам** через форму (без обязательного ввода сырого JSON).
5. Задавать **правильный ответ** по типу: выбор индекса/индексов, пары сопоставления, порядок и т.д.
6. При сохранении показывать **ошибки валидации** (нет текста, нет ответа и т.д.).
7. По желанию: **перестановка** вопросов (drag-and-drop или кнопки вверх/вниз), **дублирование** вопроса.

---

## 3. Пошаговый план для агента

Выполнять в указанном порядке, чтобы не ломать уже работающие сценарии.

---

### Этап A. Создание теста без импорта

**A.1. Разрешить создание «пустого» теста в API**

- Файл: `src/app/api/admin/tests/route.ts` (POST).
- Сейчас: проверка `questions.length === 0` и наличие ответа в `answerKey` для каждого вопроса.
- Действие: разрешить тело с `questions: []` и `answerKey: {}` (пустой объект). Либо ввести отдельный контракт, например `{ createEmpty: true, title: "Новый тест" }`, и в этом случае создавать запись с `questions = []`, `answer_key = {}`. Остальные поля — как при обычном POST (description, category, difficultyLevel, basePoints, maxAttempts — по умолчанию или из тела).

**A.2. Кнопка «Создать тест» в списке тестов**

- Файл: `src/components/AdminTestsList.tsx` (или страница `src/app/admin/tests/page.tsx`).
- Действие: добавить кнопку «Создать тест» (рядом с «Импорт JSON»). По клику: запрос `POST /api/admin/tests` с минимальным телом, например `{ title: "Новый тест", description: "", category: "", difficultyLevel: 1, basePoints: 200, maxAttempts: null, questions: [], answerKey: {} }`. Если API не принимает пустой `questions` — использовать тело из A.1 (createEmpty) или один вопрос-заглушка с `id: "q1"`, `type: "multiple-choice"`, `text: ""`, `options: []`, `answerKey: { q1: 0 }`.
- После успешного ответа: `router.push(`/admin/tests/${data.testId}/edit`)` (если API возвращает `testId`; иначе использовать сгенерированный или переданный `id`).

**A.3. Уникальный ID нового теста**

- В POST при создании пустого теста передавать `id: undefined` или не передавать — в API уже есть логика `const testId = id || \`test-${crypto.randomUUID().slice(0, 8)}\``. Убедиться, что ответ API содержит `testId` и редирект ведёт на `/admin/tests/${testId}/edit`.

---

### Этап B. Добавление и удаление вопросов в редакторе

**B.1. Кнопка «Добавить вопрос»**

- Файл: `src/app/admin/tests/[testId]/edit/page.tsx`.
- Действие: под списком вопросов кнопка «Добавить вопрос». При клике:
  - Сгенерировать новый `id` (например `q${test.questions.length + 1}` или `q-${Date.now()}`), убедиться в уникальности в рамках теста.
  - Добавить в `questions` объект вопроса по умолчанию: `{ id: newId, type: "multiple-choice", text: "", options: ["", ""], hint: "" }`.
  - Добавить в `answerKey` запись `[newId]: 0`.
  - Развернуть карточку нового вопроса (добавить индекс в `expandedQuestions`).
  - Вызвать `setTest` с обновлёнными `questions` и `answerKey`.

**B.2. Удаление вопроса**

- Уже реализовано: кнопка «Удалить вопрос», удаление из `questions` и ключа из `answerKey`. Оставить как есть, при необходимости поправить стиль/подтверждение.

---

### Этап C. Смена типа вопроса

**C.1. Выбор типа в форме**

- В блоке редактирования вопроса (в развёрнутой карточке) добавить выпадающий список «Тип вопроса» с вариантами из того же списка, что и при импорте: `multiple-choice`, `multiple-select`, `true-false-enhanced`, `cloze-dropdown`, `select-errors`, `matching`, `ordering`, `two-step`, `matrix`, `grouping`. Подписи на русском (как в текущем `questionTypeLabel`).
- Значение привязать к `q.type`; при смене — вызывать функцию «нормализации» вопроса и ответа.

**C.2. Нормализация при смене типа**

- Реализовать функцию `normalizeQuestionByType(question, type): question` и `defaultAnswerForType(type): answer`.
- При смене типа:
  - Новый объект вопроса: оставить `id`, `text`, `hint`; установить `type`; для выбранного типа заполнить обязательные поля значениями по умолчанию (пустые массивы/строки), если их ещё нет. Примеры:
    - `multiple-choice` / `multiple-select`: `options: question.options ?? [""]`.
    - `true-false-enhanced`: `statement: question.statement ?? question.text ?? ""`, `reasons: question.reasons ?? [""]`.
    - `cloze-dropdown`: `text` с плейсхолдером `[1]`, `gaps: [{ index: 0, options: [""] }]`.
    - `matching`: `leftItems: question.leftItems ?? []`, `rightItems: question.rightItems ?? []`.
    - `ordering`: `items: question.items ?? []`.
    - И т.д. по интерфейсам из `src/tests/types.ts`.
  - В `answerKey` для этого `q.id` записать `defaultAnswerForType(newType)` (например для multiple-choice — `0`, для multiple-select — `[]`, для true-false-enhanced — `{ answer: true, reason: 0 }`, для matching — `[]`, для ordering — `[]`, для cloze — массив длины gaps с нулями).
- Обновить состояние теста и разметку так, чтобы ниже отображались поля, соответствующие новому типу.

---

### Этап D. Редактирование полей по типам (без сырого JSON)

Для каждого типа вопроса в развёрнутой карточке показывать свои поля. Общие для всех: ID, текст вопроса, подсказка (hint). Остальное — по типу.

**D.1. multiple-choice / multiple-select**

- Уже есть: текст вариантов по строкам (textarea → `options`). Добавить явный выбор правильного ответа:
  - **multiple-choice**: радио или выпадающий список «Правильный ответ» — варианты «Вариант 1 (индекс 0)», «Вариант 2 (индекс 1)» и т.д.; значение → `answerKey[q.id] = number`.
  - **multiple-select**: чекбоксы по вариантам (индексы); значение → `answerKey[q.id] = number[]`.

**D.2. true-false-enhanced**

- Поле «Утверждение» (statement) — textarea.
- Поле «Варианты причин» — список строк (каждая строка — один вариант); можно textarea «каждая причина с новой строки» или динамический список с кнопкой «Добавить причину».
- Правильный ответ: радио «Верно / Неверно» + выпадающий список «Причина» (индекс в `reasons`). Значение в answerKey: `{ answer: boolean, reason: number }`.

**D.3. cloze-dropdown**

- Текст вопроса с плейсхолдерами: подсказка «Используйте [1], [2] для пропусков».
- Блок «Пропуски»: массив `gaps`. Каждый элемент: индекс (number), варианты (массив строк, например по строкам). Кнопки «Добавить пропуск», «Удалить пропуск».
- Правильный ответ: для каждого пропуска — выпадающий список «Выбор для пропуска 1» и т.д. (индекс выбранного варианта). Значение в answerKey: `number[]`.

**D.4. matching**

- Два списка: «Левый столбец» (leftItems), «Правый столбец» (rightItems) — каждый элемент строка (textarea по строкам или динамический список).
- Правильный ответ: задать пары «левый i — правый j». Вариант UI: для каждого левого элемента — выпадающий список «Сопоставить с» (правые по индексу). Значение в answerKey: `[number, number][]` (массив пар [leftIndex, rightIndex]).

**D.5. ordering**

- Список элементов (items) — каждая строка один элемент (textarea по строкам или динамический список).
- Правильный ответ: порядок индексов. UI: отобразить элементы и дать возможность задать порядок (например поля «Позиция 1 = элемент № …», или drag-and-drop списка «Правильный порядок»). Значение в answerKey: `number[]`.

**D.6. Остальные типы (select-errors, two-step, matrix, grouping)**

- По тому же принципу: вынести из `types.ts` поля вопроса и формат ответа, добавить в редактор блоки ввода (текст, списки, числа) и выбор ответа (индексы/пары/объект). Для двухступенчатого и матрицы можно временно оставить «Расширенный JSON» с подсказкой по формату, затем заменить на пошаговые поля.
- Приоритет после D.1–D.5: select-errors, two-step, matrix, grouping — по необходимости.

**D.7. Убрать или скрыть сырой JSON ответа**

- После введения пошагового ввода ответа для основных типов поле «Правильный ответ (JSON)» можно скрыть по умолчанию или оставить в `<details>` «Для продвинутых: редактировать JSON ответа» на случай нестандартных значений.

---

### Этап E. Валидация перед сохранением

**E.1. Функция валидации теста на клиенте**

- Вынести или продублировать логику, близкую к `validateTestJson` из страницы импорта: наличие `title`, непустой `questions`, у каждого вопроса — `id`, `type`, `text`; для каждого типа — наличие нужных полей (options, gaps, leftItems/rightItems, items и т.д.); в `answerKey` есть ключ для каждого `q.id` и тип значения соответствует типу вопроса.
- Возвращать список ошибок `{ field, message }`.

**E.2. Показ ошибок при сохранении**

- По нажатию «Сохранить» сначала запускать валидацию. Если есть ошибки — показать блок с перечислением (как на странице импорта), не отправлять PUT. Если ошибок нет — выполнять PUT и показывать успех/ошибку от сервера.

**E.3. Валидация на API (PUT)**

- В `src/app/api/admin/tests/[testId]/route.ts` (PUT) при необходимости усилить проверки (наличие ответа для каждого вопроса, тип ответа). Либо оставить мягкую валидацию и полагаться на редактор.

---

### Этап F. Улучшения UX (по возможности)

**F.1. Перестановка вопросов**

- Кнопки «Вверх» / «Вниз» у каждой карточки вопроса или drag-and-drop (например библиотека `@dnd-kit` или нативный HTML5 DnD). При изменении порядка менять только порядок элементов в `test.questions`; `answerKey` по ключам не меняется.

**F.2. Дублирование вопроса**

- Кнопка «Дублировать»: копировать объект вопроса, присвоить новый `id`, добавить в `questions` и в `answerKey` скопированное значение ответа. Развернуть новую карточку.

**F.3. Навигация и автосохранение**

- Хлебные крошки: Админка → Тесты → Редактирование «Название теста».
- Опционально: автосохранение черновика (debounce 2–3 сек) в localStorage или отдельный endpoint «черновик», чтобы не терять данные при случайном уходе со страницы.

---

## 4. Технические ориентиры

- **Типы и форматы ответов**: `src/tests/types.ts` (QuestionAnswer, типы вопросов), `src/lib/answer-checkers.ts` (как проверяется ответ).
- **Существующий редактор**: `src/app/admin/tests/[testId]/edit/page.tsx`.
- **Валидация импорта**: `src/app/admin/tests/import/page.tsx` (функция `validateTestJson`, список `validTypes`).
- **API создания теста**: `src/app/api/admin/tests/route.ts` (POST).
- **API обновления теста**: `src/app/api/admin/tests/[testId]/route.ts` (PUT).

Создание пустого теста и добавление вопросов не должны ломать превью и прохождение теста пользователем: при пустом списке вопросов превью/прохождение должны корректно обрабатывать 0 вопросов (уже может требоваться проверка в `TestPreviewPage` и на странице прохождения).

---

## 5. Порядок выполнения для агента (чек-лист)

1. **Этап A**: создание пустого теста (API + кнопка в списке).
2. **Этап B**: добавление вопроса в редакторе (кнопка «Добавить вопрос»).
3. **Этап C**: выбор типа вопроса и нормализация структуры + answerKey при смене типа.
4. **Этап D**: пошаговые поля и ввод ответа для типов: multiple-choice, multiple-select, true-false-enhanced, cloze-dropdown, matching, ordering (D.1–D.5); при необходимости D.6.
5. **Этап E**: валидация перед сохранением и отображение ошибок.
6. **Этап F**: перестановка вопросов, дублирование, при желании автосохранение/хлебные крошки.

После выполнения этого плана администратор сможет полностью настраивать тесты вручную через интерфейс, без правки JSON.
